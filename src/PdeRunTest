using Flux, DiffEqBase
include("PdeSolve.jl")

# one-dimensional heat equation
x0 = [8]
t0 = 0
tn = 5
T = tn
dt = 0.5
d = 1 # number of dimensions
m = 150 # number of trajectories (batch size)
grid = (x0, t0, tn, dt, d, m)

g(x) = sum(x.^2)
f(x,t) = 0
μ(x,t) = 0
σ(x,t) = 1
prob = (g, f, μ, σ)

hide_layer_size  = 10 + d
opt = Flux.ADAM(0.1)
getNeuranNetwork(hide_layer_size, d) = Flux.Chain(
                                            Dense(d,hide_layer_size,relu),
                                            Dense(hide_layer_size,hide_layer_size,relu),
                                            Dense(hide_layer_size,hide_layer_size,relu),
                                            Dense(hide_layer_size,d))

neurNetParam = (hide_layer_size, opt, getNeuranNetwork)

ans = pde_solve(prob, grid, neurNetParam, verbose = true, abstol=1e-8, maxiters = 100)

u_analytical(x,t) = sum(x.^2) .+ d*t
analytical_ans = u_analytical(x0, T)
error = abs(ans - analytical_ans)

println("numerical = ", ans)
println("analytical = " ,analytical_ans)
println("error = ", error)

# high-dimensional heat equation
d = 30 # number of dimensions
x0 = fill(8,d) #[8,8]
t0 = 0
tn = 2
T = tn
dt = 0.5
m = 300 # number of trajectories (batch size)
grid = (x0, t0, tn, dt, d, m)

g(x) = sum(x.^2)
f(x,t) = 0
μ(x,t) = 0
σ(x,t) = 1
prob = (g, f, μ, σ)

hide_layer_size  = 10 + d
opt = Flux.ADAM(0.1)
getNeuranNetwork(hide_layer_size, d) = Flux.Chain(
                                            Dense(d,hide_layer_size,relu),
                                            Dense(hide_layer_size,hide_layer_size,relu),
                                            Dense(hide_layer_size,hide_layer_size,relu),
                                            Dense(hide_layer_size,d))

neurNetParam = (hide_layer_size, opt, getNeuranNetwork)

ans = pde_solve(prob, grid, neurNetParam, verbose = true, abstol=1e-8, maxiters = 300)

u_analytical(x,t) = sum(x.^2) .+ d*t
analytical_ans = u_analytical(x0, T)
error = abs(ans - analytical_ans)

println("numerical = ", ans)
println("analytical = " ,analytical_ans)
println("error = ", error)

#Hamilton Jacobi Bellman Equation
# f(x, Y, Z) =  0.05*(Y - sum(X*Z)) # M x 1
# g(x,Y,Z) = sum(x.^2) # # M x D
# μ( t, X, Y, Z)
# σ(self, t, X, Y) = 0.4*Diagonal(x)

# Allen-Cahn Equation
# x0 = 0
# t0 = 0
# tn = 0.3
# T = tn
# dt = 0.4
# d = 1 #dimention
# m = 100 #count of trajectories
# grid = (x0, t0, tn, dt, d, m),
# g(x) = 1.0/(2.0 + 0.4*sum(x^2)


# one-dimensional test case
# x0 = -2
# t0 = 0
# tn = 2
# T = tn
# dt = 0.4
# d = 1 #dimention
# m = 100 #count of trajectories
# grid = (x0, t0, tn, dt, d, m)
#
# g(x) = cos(x)
# f(x,t) = (cos(x)*(exp((T-t)/2) + (σ(x,t)^2)/2) + µ(x,t)*sin(x))*exp((T-t)/2) - 1/2*(sin(x)*cos(x)*exp(T-t))^2
# μ(x,t) = 0
# σ(x,t) = 1
# prob = (g, f, μ, σ)
#
# ans = pde_solve(prob, grid, verbose = true, abstol=1e-8, maxiters = 200)
# anlitical_solution(x,t)  = exp((T -t)/2)*cos(x)
# println(ans, " " , anlitical_solution(x0, t0), " ", anlitical_solution(x0, T))
